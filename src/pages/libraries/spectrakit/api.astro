---
import ProseLayout from "@layouts/ProseLayout.astro";
import Badge from "@components/ui/Badge.astro";
import { SITE } from "@lib/constants";

const canonicalUrl = new URL("/libraries/spectrakit/api", SITE.url).toString();

const breadcrumbSchema = {
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    { "@type": "ListItem", "position": 1, "name": "Home", "item": SITE.url },
    { "@type": "ListItem", "position": 2, "name": "Libraries", "item": `${SITE.url}/libraries` },
    { "@type": "ListItem", "position": 3, "name": "SpectraKit", "item": `${SITE.url}/libraries/spectrakit` },
    { "@type": "ListItem", "position": 4, "name": "API Reference", "item": canonicalUrl },
  ],
};

interface FunctionDef {
  name: string;
  sig: string;
  desc: string;
  params?: { name: string; type: string; desc: string }[];
  returns?: string;
  example?: string;
}

interface ModuleDef {
  name: string;
  id: string;
  desc: string;
  functions: FunctionDef[];
}

const modules: ModuleDef[] = [
  {
    name: "spectrakit.baseline",
    id: "baseline",
    desc: "Baseline correction algorithms. All functions return the corrected spectrum. Pass return_info=True to get convergence diagnostics (iterations, residual norm).",
    functions: [
      {
        name: "baseline_als",
        sig: "baseline_als(y, lam=1e6, p=0.01, max_iter=50, tol=1e-5, return_info=False)",
        desc: "Asymmetric Least Squares baseline correction. Uses Whittaker smoothing with asymmetric weighting.",
        params: [
          { name: "y", type: "ndarray", desc: "Input spectrum (1D) or batch of spectra (2D, rows = spectra)" },
          { name: "lam", type: "float", desc: "Smoothness parameter. Larger = smoother baseline (1e4–1e8)" },
          { name: "p", type: "float", desc: "Asymmetry weight. Smaller = more aggressive baseline removal (0.001–0.1)" },
          { name: "return_info", type: "bool", desc: "If True, return (corrected, ConvergenceInfo) tuple" },
        ],
        returns: "ndarray — baseline-corrected spectrum, same shape as input",
        example: "from spectrakit.baseline import baseline_als\ncorrected = baseline_als(spectrum, lam=1e6, p=0.01)",
      },
      {
        name: "baseline_arpls",
        sig: "baseline_arpls(y, lam=1e6, ratio=0.01, max_iter=50, tol=1e-5, return_info=False)",
        desc: "Asymmetrically Reweighted Penalized Least Squares. More robust than ALS for spectra with broad peaks overlapping the baseline.",
        params: [
          { name: "y", type: "ndarray", desc: "Input spectrum or batch" },
          { name: "lam", type: "float", desc: "Smoothness parameter" },
          { name: "ratio", type: "float", desc: "Convergence ratio threshold" },
        ],
        returns: "ndarray — corrected spectrum",
        example: "from spectrakit.baseline import baseline_arpls\ncorrected = baseline_arpls(spectrum, lam=1e5)",
      },
      {
        name: "baseline_snip",
        sig: "baseline_snip(y, n_iter=40)",
        desc: "Statistics-sensitive Non-linear Iterative Peak-clipping. Non-parametric, no smoothness parameter to tune.",
        params: [
          { name: "y", type: "ndarray", desc: "Input spectrum or batch" },
          { name: "n_iter", type: "int", desc: "Number of clipping iterations (20–100)" },
        ],
        returns: "ndarray — corrected spectrum",
        example: "corrected = baseline_snip(spectrum, n_iter=40)",
      },
      {
        name: "baseline_poly",
        sig: "baseline_poly(y, x=None, degree=3, mask=None)",
        desc: "Polynomial baseline fitting. Optionally mask peak regions to exclude from the fit.",
        params: [
          { name: "degree", type: "int", desc: "Polynomial degree (1–7)" },
          { name: "mask", type: "ndarray | None", desc: "Boolean mask — True = baseline region, False = peak region" },
        ],
        returns: "ndarray — corrected spectrum",
        example: "corrected = baseline_poly(spectrum, degree=5)",
      },
      {
        name: "baseline_rubberband",
        sig: "baseline_rubberband(y, x=None)",
        desc: "Rubber band (convex hull) baseline. Fits the lower envelope of the spectrum.",
        returns: "ndarray — corrected spectrum",
        example: "corrected = baseline_rubberband(spectrum)",
      },
    ],
  },
  {
    name: "spectrakit.smooth",
    id: "smooth",
    desc: "Spectral smoothing and noise reduction. All functions preserve the spectral length.",
    functions: [
      {
        name: "smooth_savgol",
        sig: "smooth_savgol(y, window_length=11, polyorder=2, deriv=0)",
        desc: "Savitzky-Golay smoothing. Polynomial fit in a sliding window. Preserves peak positions and heights better than moving average.",
        params: [
          { name: "window_length", type: "int", desc: "Window size (must be odd, 5–41)" },
          { name: "polyorder", type: "int", desc: "Polynomial order (must be < window_length)" },
          { name: "deriv", type: "int", desc: "Derivative order (0 = smooth only)" },
        ],
        returns: "ndarray — smoothed spectrum",
        example: "from spectrakit.smooth import smooth_savgol\nsmoothed = smooth_savgol(spectrum, window_length=11, polyorder=2)",
      },
      {
        name: "smooth_whittaker",
        sig: "smooth_whittaker(y, lam=1e3, x=None)",
        desc: "Whittaker smoother with optional wavenumber-aware penalty. When x (wavenumber axis) is provided, the penalty adapts to non-uniform spacing.",
        params: [
          { name: "lam", type: "float", desc: "Smoothness penalty (1e1–1e6)" },
          { name: "x", type: "ndarray | None", desc: "Wavenumber axis for spacing-aware smoothing" },
        ],
        returns: "ndarray — smoothed spectrum",
        example: "smoothed = smooth_whittaker(spectrum, lam=1e3, x=wavenumbers)",
      },
    ],
  },
  {
    name: "spectrakit.normalize",
    id: "normalize",
    desc: "Spectral normalization. Standardizes intensity scales across samples for fair comparison and model training.",
    functions: [
      {
        name: "normalize_snv",
        sig: "normalize_snv(y)",
        desc: "Standard Normal Variate. Centers each spectrum to zero mean and unit variance. The most common normalization for multivariate calibration.",
        returns: "ndarray — SNV-normalized spectrum",
        example: "from spectrakit.normalize import normalize_snv\nnormed = normalize_snv(spectra)  # works on 1D or 2D",
      },
      {
        name: "normalize_minmax",
        sig: "normalize_minmax(y, feature_range=(0, 1))",
        desc: "Min-max scaling to a specified range.",
        returns: "ndarray — scaled spectrum",
        example: "normed = normalize_minmax(spectrum, feature_range=(0, 1))",
      },
      {
        name: "normalize_area",
        sig: "normalize_area(y, x=None)",
        desc: "Area normalization. Divides by the integrated area under the spectrum. When x is provided, uses trapezoidal integration with proper wavenumber spacing.",
        returns: "ndarray — area-normalized spectrum",
        example: "normed = normalize_area(spectrum, x=wavenumbers)",
      },
      {
        name: "normalize_l2",
        sig: "normalize_l2(y)",
        desc: "L2 vector normalization. Scales each spectrum to unit Euclidean norm.",
        returns: "ndarray — L2-normalized spectrum",
        example: "normed = normalize_l2(spectrum)",
      },
    ],
  },
  {
    name: "spectrakit.derivative",
    id: "derivative",
    desc: "Spectral derivatives. First and second derivatives resolve overlapping peaks and remove baseline offsets.",
    functions: [
      {
        name: "deriv_savgol",
        sig: "deriv_savgol(y, window_length=11, polyorder=2, deriv=1)",
        desc: "Savitzky-Golay derivative. Simultaneous smoothing and differentiation.",
        params: [
          { name: "deriv", type: "int", desc: "Derivative order (1 = first, 2 = second)" },
        ],
        returns: "ndarray — derivative spectrum",
        example: "from spectrakit.derivative import deriv_savgol\nd1 = deriv_savgol(spectrum, deriv=1)\nd2 = deriv_savgol(spectrum, deriv=2)",
      },
      {
        name: "deriv_norris_williams",
        sig: "deriv_norris_williams(y, gap=5, segment=5, deriv=1)",
        desc: "Norris-Williams gap-segment derivative. More robust to noise than Savitzky-Golay for NIR spectra.",
        params: [
          { name: "gap", type: "int", desc: "Gap size between segments" },
          { name: "segment", type: "int", desc: "Averaging segment size" },
        ],
        returns: "ndarray — derivative spectrum",
        example: "d1 = deriv_norris_williams(spectrum, gap=5, segment=5)",
      },
    ],
  },
  {
    name: "spectrakit.scatter",
    id: "scatter",
    desc: "Scatter correction for diffuse reflectance and transmission spectra affected by particle size variation.",
    functions: [
      {
        name: "scatter_msc",
        sig: "scatter_msc(y, reference=None)",
        desc: "Multiplicative Scatter Correction. Regresses each spectrum against a reference (default: mean spectrum) and removes the scatter component.",
        params: [
          { name: "reference", type: "ndarray | None", desc: "Reference spectrum. If None, uses the mean of y (requires 2D input)" },
        ],
        returns: "ndarray — scatter-corrected spectra",
        example: "from spectrakit.scatter import scatter_msc\ncorrected = scatter_msc(spectra)  # 2D: rows = samples",
      },
      {
        name: "scatter_emsc",
        sig: "scatter_emsc(y, x=None, degree=2, reference=None)",
        desc: "Extended MSC with Legendre polynomial basis. Handles wavelength-dependent scatter effects that basic MSC misses.",
        params: [
          { name: "degree", type: "int", desc: "Polynomial degree for scatter model (1–4)" },
        ],
        returns: "ndarray — corrected spectra",
        example: "corrected = scatter_emsc(spectra, x=wavenumbers, degree=2)",
      },
    ],
  },
  {
    name: "spectrakit.transform",
    id: "transform",
    desc: "Physical transforms between spectral representations.",
    functions: [
      {
        name: "kubelka_munk",
        sig: "kubelka_munk(reflectance)",
        desc: "Kubelka-Munk transform. Converts diffuse reflectance to a quantity proportional to concentration: f(R) = (1-R)² / 2R.",
        returns: "ndarray — K-M transformed spectrum",
        example: "from spectrakit.transform import kubelka_munk\nkm = kubelka_munk(reflectance)",
      },
      {
        name: "atr_correct",
        sig: "atr_correct(y, x, n_sample=1.5, n_crystal=2.4, angle=45.0)",
        desc: "ATR correction. Compensates for the wavenumber-dependent penetration depth in attenuated total reflectance spectra.",
        returns: "ndarray — corrected spectrum",
        example: "corrected = atr_correct(spectrum, wavenumbers, n_sample=1.5)",
      },
      {
        name: "absorbance_to_transmittance",
        sig: "absorbance_to_transmittance(y)",
        desc: "Convert absorbance to transmittance: T = 10^(-A).",
        returns: "ndarray",
        example: "trans = absorbance_to_transmittance(absorbance)",
      },
      {
        name: "transmittance_to_absorbance",
        sig: "transmittance_to_absorbance(y)",
        desc: "Convert transmittance to absorbance: A = -log10(T).",
        returns: "ndarray",
        example: "absorb = transmittance_to_absorbance(transmittance)",
      },
    ],
  },
  {
    name: "spectrakit.peaks",
    id: "peaks",
    desc: "Peak detection, integration, and characterization.",
    functions: [
      {
        name: "find_peaks",
        sig: "find_peaks(y, x=None, height=None, prominence=0.01, distance=5)",
        desc: "Detect peaks with optional filtering by height, prominence, and minimum distance. Returns PeakResult with positions, heights, widths, and areas.",
        returns: "PeakResult — named tuple with indices, positions, heights, prominences, widths, areas",
        example: "from spectrakit.peaks import find_peaks\npeaks = find_peaks(spectrum, x=wavenumbers, prominence=0.05)\nprint(peaks.positions, peaks.heights)",
      },
      {
        name: "integrate_peak",
        sig: "integrate_peak(y, x=None, left=None, right=None, baseline='linear')",
        desc: "Integrate a single peak between bounds. Supports linear and polynomial baseline subtraction under the peak.",
        returns: "float — integrated peak area",
        example: "area = integrate_peak(spectrum, x=wn, left=1600, right=1800)",
      },
    ],
  },
  {
    name: "spectrakit.despike",
    id: "despike",
    desc: "Cosmic ray and spike removal for Raman spectra.",
    functions: [
      {
        name: "despike_whitaker_hayes",
        sig: "despike_whitaker_hayes(y, threshold=5.0, window=7)",
        desc: "Whitaker-Hayes despiking. Detects spikes using the modified Z-score of the second derivative, then replaces them by interpolation.",
        params: [
          { name: "threshold", type: "float", desc: "Z-score threshold for spike detection (3–8)" },
          { name: "window", type: "int", desc: "Interpolation window size" },
        ],
        returns: "ndarray — despiked spectrum",
        example: "from spectrakit.despike import despike_whitaker_hayes\nclean = despike_whitaker_hayes(raman_spectrum, threshold=5.0)",
      },
      {
        name: "despike_zscore",
        sig: "despike_zscore(y, threshold=3.5, window=11)",
        desc: "Rolling modified Z-score despiking. Simpler but less sensitive than Whitaker-Hayes for narrow spikes.",
        returns: "ndarray — despiked spectrum",
        example: "clean = despike_zscore(spectrum, threshold=3.5)",
      },
    ],
  },
  {
    name: "spectrakit.quality",
    id: "quality",
    desc: "Spectral quality metrics for automated quality control.",
    functions: [
      {
        name: "roughness",
        sig: "roughness(y)",
        desc: "RMS of first-order finite differences. Lower = smoother. Useful for detecting noisy or corrupted spectra.",
        returns: "float — roughness value",
        example: "from spectrakit.quality import roughness\nr = roughness(spectrum)\nif r > 0.1: print('noisy spectrum')",
      },
      {
        name: "snr",
        sig: "snr(y, signal_range=None, noise_range=None)",
        desc: "Signal-to-noise ratio. Ratio of peak signal to RMS noise in a specified baseline region.",
        returns: "float — SNR in dB",
        example: "from spectrakit.quality import snr\nratio = snr(spectrum, signal_range=(2800, 3000), noise_range=(1800, 2000))",
      },
    ],
  },
  {
    name: "spectrakit.similarity",
    id: "similarity",
    desc: "Spectral similarity and distance metrics. All functions support 1D (single pair) and 2D (pairwise matrix) inputs.",
    functions: [
      {
        name: "cosine_similarity",
        sig: "cosine_similarity(a, b=None)",
        desc: "Cosine similarity. When b is None and a is 2D, computes the full pairwise similarity matrix.",
        returns: "float or ndarray — similarity score(s) in [0, 1]",
        example: "from spectrakit.similarity import cosine_similarity\nsim = cosine_similarity(spectrum_a, spectrum_b)  # scalar\nmatrix = cosine_similarity(spectra_2d)  # (N, N) matrix",
      },
      {
        name: "spectral_angle",
        sig: "spectral_angle(a, b=None)",
        desc: "Spectral Angle Mapper (SAM). Angle between spectra in N-dimensional space. Insensitive to intensity scaling.",
        returns: "float or ndarray — angle in radians",
        example: "angle = spectral_angle(spectrum_a, spectrum_b)",
      },
      {
        name: "pearson_correlation",
        sig: "pearson_correlation(a, b=None)",
        desc: "Pearson correlation coefficient between spectra.",
        returns: "float or ndarray",
        example: "r = pearson_correlation(spectrum_a, spectrum_b)",
      },
    ],
  },
  {
    name: "spectrakit.io",
    id: "io",
    desc: "File I/O for common spectral formats. All readers return a named tuple with wavenumbers, intensities, and metadata.",
    functions: [
      {
        name: "read_jcamp",
        sig: "read_jcamp(path)",
        desc: "Read JCAMP-DX files (.dx, .jdx). Handles all 6 JCAMP variants including AFFN, PAC, SQZ, DIF, DIFDUP, and NTUPLE.",
        returns: "SpectrumData(wavenumbers, intensities, metadata)",
        example: "from spectrakit.io import read_jcamp\nspec = read_jcamp('sample.dx')\nprint(spec.wavenumbers.shape, spec.intensities.shape)",
      },
      {
        name: "read_spc",
        sig: "read_spc(path)",
        desc: "Read Thermo/Galactic SPC binary files. Handles single and multi-trace files from Thermo, PerkinElmer, and Shimadzu instruments.",
        returns: "SpectrumData or list[SpectrumData]",
        example: "spec = read_spc('measurement.spc')",
      },
      {
        name: "read_opus",
        sig: "read_opus(path)",
        desc: "Read Bruker OPUS binary files. Native parser — no Bruker SDK required. Handles single-channel, interferogram, and ratioed spectra.",
        returns: "SpectrumData",
        example: "spec = read_opus('sample.0')",
      },
      {
        name: "read_csv",
        sig: "read_csv(path, x_col=0, y_col=1, delimiter=',', skip_header=1)",
        desc: "Read CSV/TSV spectral files with configurable column mapping.",
        returns: "SpectrumData",
        example: "spec = read_csv('data.csv', x_col=0, y_col=1)",
      },
    ],
  },
  {
    name: "spectrakit.pipeline",
    id: "pipeline",
    desc: "Composable preprocessing pipelines with scikit-learn integration.",
    functions: [
      {
        name: "Pipeline",
        sig: "Pipeline(steps=None)",
        desc: "Ordered chain of preprocessing steps. Each step is a (name, function, kwargs) tuple. Call .transform(y) to apply all steps in order.",
        returns: "Pipeline instance",
        example: "from spectrakit.pipeline import Pipeline\nfrom spectrakit.baseline import baseline_als\nfrom spectrakit.normalize import normalize_snv\n\npipe = Pipeline([\n    ('baseline', baseline_als, {'lam': 1e6}),\n    ('normalize', normalize_snv, {}),\n])\nresult = pipe.transform(spectra)",
      },
      {
        name: "SpectralTransformer",
        sig: "SpectralTransformer(pipeline)",
        desc: "scikit-learn compatible transformer wrapping a SpectraKit Pipeline. Implements fit(), transform(), and fit_transform() for use in sklearn.pipeline.make_pipeline and GridSearchCV.",
        returns: "SpectralTransformer instance",
        example: "from spectrakit.sklearn import SpectralTransformer\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.cross_decomposition import PLSRegression\n\nmodel = make_pipeline(\n    SpectralTransformer(pipe),\n    PLSRegression(n_components=5)\n)\nmodel.fit(X_train, y_train)",
      },
    ],
  },
  {
    name: "spectrakit.ops",
    id: "ops",
    desc: "Spectral arithmetic and alignment operations.",
    functions: [
      {
        name: "subtract",
        sig: "subtract(a, b)",
        desc: "Subtract spectrum b from a. Useful for solvent subtraction and difference spectroscopy.",
        returns: "ndarray",
        example: "from spectrakit.ops import subtract\ndiff = subtract(sample, solvent)",
      },
      {
        name: "interpolate",
        sig: "interpolate(y, x_old, x_new, method='linear')",
        desc: "Resample a spectrum to a new wavenumber grid. Supports linear, cubic, and akima interpolation.",
        returns: "ndarray — resampled spectrum",
        example: "resampled = interpolate(spectrum, old_wn, new_wn, method='cubic')",
      },
      {
        name: "align",
        sig: "align(y, reference, x=None, max_shift=10)",
        desc: "Cross-correlation-based spectral alignment. Corrects small wavenumber shifts between spectra.",
        returns: "ndarray — aligned spectrum",
        example: "aligned = align(spectrum, reference, max_shift=5)",
      },
    ],
  },
];
---

<ProseLayout
  title="SpectraKit API Reference"
  description="Complete API reference for SpectraKit — Python functions for baseline correction, smoothing, normalization, peak detection, scatter correction, I/O, and spectral pipelines."
>
  <script type="application/ld+json" set:html={JSON.stringify(breadcrumbSchema)} />

  <header class="mb-12 not-prose">
    <div class="flex items-center gap-2">
      <Badge>python</Badge>
      <Badge variant="outline">v1.8.0</Badge>
    </div>
    <h1 class="mt-4 text-3xl font-heading font-bold text-text-primary">
      SpectraKit API Reference
    </h1>
    <p class="mt-2 text-text-secondary">
      Every public function in SpectraKit. All functions accept and return NumPy arrays.
      Install: <code class="text-accent">pip install pyspectrakit</code>
    </p>
    <p class="mt-2 text-sm text-text-muted">
      <a href="/libraries/spectrakit" class="text-accent hover:underline">Overview</a> ·
      <a href="/blog/spectrakit" class="text-accent hover:underline">Design post</a> ·
      <a href="https://github.com/ktubhyam/spectrakit" target="_blank" rel="noopener noreferrer" class="text-accent hover:underline">GitHub</a>
    </p>
  </header>

  <!-- Table of Contents -->
  <nav class="not-prose mb-10 rounded-xl border border-border bg-bg-secondary p-5">
    <p class="text-xs font-mono text-text-muted uppercase tracking-wider mb-3">Modules</p>
    <div class="grid grid-cols-2 sm:grid-cols-3 gap-2">
      {modules.map((mod) => (
        <a
          href={`#${mod.id}`}
          class="text-sm text-text-muted hover:text-accent transition-colors duration-200"
        >
          {mod.id}
        </a>
      ))}
    </div>
  </nav>

  <!-- Modules -->
  {modules.map((mod) => (
    <section class="mb-16 not-prose" id={mod.id}>
      <div class="border-b border-border pb-3 mb-6">
        <h2 class="text-xl font-heading font-medium text-text-primary">
          <code class="text-accent">{mod.name}</code>
        </h2>
        <p class="mt-1 text-sm text-text-muted">{mod.desc}</p>
      </div>

      {mod.functions.map((fn) => (
        <div class="mb-8 pl-4 border-l-2 border-border hover:border-accent/40 transition-colors">
          <h3 class="font-mono text-sm text-text-primary mb-1">
            <span class="text-accent">{fn.name}</span>
          </h3>
          <pre class="text-xs text-text-muted font-mono mb-2 overflow-x-auto">{fn.sig}</pre>
          <p class="text-sm text-text-secondary mb-3">{fn.desc}</p>

          {fn.params && fn.params.length > 0 && (
            <div class="mb-3">
              <p class="text-xs font-mono text-text-muted uppercase tracking-wider mb-1">Parameters</p>
              <div class="space-y-1">
                {fn.params.map((p) => (
                  <div class="text-sm">
                    <code class="text-accent/80">{p.name}</code>
                    <span class="text-text-muted"> : {p.type}</span>
                    <span class="text-text-secondary"> — {p.desc}</span>
                  </div>
                ))}
              </div>
            </div>
          )}

          {fn.returns && (
            <div class="mb-3">
              <p class="text-xs font-mono text-text-muted uppercase tracking-wider mb-1">Returns</p>
              <p class="text-sm text-text-secondary">{fn.returns}</p>
            </div>
          )}

          {fn.example && (
            <pre class="text-xs bg-bg-secondary rounded-lg p-3 font-mono text-text-secondary overflow-x-auto"><code>{fn.example}</code></pre>
          )}
        </div>
      ))}
    </section>
  ))}

  <div class="not-prose mt-16 pt-8 border-t border-border">
    <p class="text-sm text-text-muted">
      Full source code on <a href="https://github.com/ktubhyam/spectrakit" target="_blank" rel="noopener noreferrer" class="text-accent hover:underline">GitHub</a>.
      See the <a href="/blog/spectrakit" class="text-accent hover:underline">design post</a> for the philosophy behind these APIs.
    </p>
  </div>
</ProseLayout>
