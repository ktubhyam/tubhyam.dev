---
title: "SpectraView: Canvas-First Spectral Visualization for the Browser"
date: 2026-02-26
description: "Why spectral viewers need Canvas for data and SVG for everything else, how composable hooks replace monolithic components, and what it takes to render 10K-point spectra at 60fps with snap-to-data crosshairs."
tags: ["typescript", "react", "spectroscopy", "open-source", "visualization"]
draft: false
---

import TerminalBlock from '@components/islands/TerminalBlock';
import CodeComparison from '@components/islands/CodeComparison';

Most spectrum viewers on the web use Plotly, Chart.js, or an SVG-based charting library. These work fine for 50-point bar charts. They do not work for vibrational spectra — 2,048 to 8,192 data points, sub-wavenumber precision, users who zoom in to inspect individual peak shoulders. The DOM chokes. Interactions lag. Scientists go back to Origin.

SpectraView exists because I needed a spectrum viewer for [Spektron](/projects/spektron) that could render IR and Raman spectra in the browser without compromise. It's a React component — <span class="highlight">npm install spectraview</span> — that renders spectral data on Canvas and everything else on SVG.

<TerminalBlock
  client:visible
  title="install + use"
  lines={[
    { spans: [{ text: "$ npm install spectraview", color: "muted" }] },
    { spans: [{ text: "" }], delay: 200 },
    { spans: [
      { text: "added ", color: "muted" },
      { text: "spectraview@1.8.1", color: "green" },
      { text: " (5 deps, 48KB ESM)", color: "muted" },
    ] },
  ]}
/>

## The Rendering Split

A spectrum is a dense polyline — thousands of (x, y) pairs connected by segments. SVG represents each segment as a DOM node. At 4,000 points, that's 4,000 `<line>` or `<path>` elements that the browser must lay out, paint, and composite. Zooming reflows the entire subtree.

Canvas has none of this overhead. `ctx.lineTo()` draws to a pixel buffer. 10,000 points take the same time as 100. But Canvas has no event model, no hover detection, no accessible text.

SpectraView uses <span class="highlight-teal">both</span>. The spectral data renders on Canvas for performance. Axes, grid lines, peak markers, annotations, and the crosshair render as SVG for interactivity and accessibility. The layers are composited by absolute positioning within a single container.

<CodeComparison
  client:visible
  title="Rendering architecture"
  beforeTitle="SVG-only (typical)"
  afterTitle="Canvas + SVG (SpectraView)"
  before={[
    { text: "<!-- Every data point is a DOM node -->", type: "comment" },
    { text: "<svg width={800} height={400}>", type: "removed" },
    { text: "  <path d='M0,100 L1,102 L2,98 ...' />", type: "removed" },
    { text: "  <!-- 4000+ path segments -->", type: "comment" },
    { text: "  <circle cx={200} cy={50} />  <!-- peak -->", type: "removed" },
    { text: "  <line x1={0} x2={800} />     <!-- axis -->", type: "removed" },
    { text: "</svg>", type: "removed" },
  ]}
  after={[
    { text: "<!-- Canvas: pixel buffer, zero DOM nodes -->", type: "comment" },
    { text: "<canvas />  {/* 10K points at 60fps */}", type: "added" },
    { text: "", type: "comment" },
    { text: "<!-- SVG: only interactive elements -->", type: "comment" },
    { text: "<svg>  {/* axes + peaks + crosshair */}", type: "added" },
    { text: "  <g class='axis' />     {/* ~20 ticks */}", type: "added" },
    { text: "  <circle />             {/* peak marker */}", type: "added" },
    { text: "</svg>", type: "added" },
  ]}
/>

## LTTB Downsampling

Even Canvas has limits. Drawing 50,000 `lineTo` calls per frame during a zoom animation is wasteful — most segments map to the same pixel column. SpectraView uses the <span class="highlight">Largest-Triangle-Three-Buckets</span> (LTTB) algorithm to reduce the rendered point count to `plotWidth * 2` while preserving visual fidelity.

LTTB divides the data into equal-sized buckets and selects the point in each bucket that forms the largest triangle with its neighbors. Unlike simple min-max decimation, it preserves the visual shape of peaks and shoulders. The downsampling happens per frame on the zoomed window, so you never lose resolution — zoom in and the algorithm selects more detail.

## Composable Architecture

SpectraView is not a monolithic charting component. It's <span class="highlight-teal">15 components and 9 hooks</span> that compose together. The main `<SpectraView />` component is a convenience wrapper — every internal layer is independently exported.

<TerminalBlock
  client:visible
  title="composition.tsx"
  lines={[
    { spans: [{ text: "// Use the batteries-included component", color: "muted" }] },
    { prompt: "", spans: [
      { text: "import ", color: "purple" },
      { text: "{ SpectraView } ", color: "white" },
      { text: "from ", color: "purple" },
      { text: "\"spectraview\"", color: "green" },
    ] },
    { spans: [{ text: "" }] },
    { spans: [{ text: "// Or compose your own from primitives", color: "muted" }] },
    { prompt: "", spans: [
      { text: "import ", color: "purple" },
      { text: "{", color: "white" },
    ] },
    { spans: [
      { text: "  SpectrumCanvas,  ", color: "teal" },
      { text: "// Canvas data layer", color: "muted" },
    ] },
    { spans: [
      { text: "  AxisLayer,       ", color: "teal" },
      { text: "// SVG axes + grid", color: "muted" },
    ] },
    { spans: [
      { text: "  PeakMarkers,     ", color: "teal" },
      { text: "// SVG peak annotations", color: "muted" },
    ] },
    { spans: [
      { text: "  Crosshair,       ", color: "teal" },
      { text: "// Snap-to-data cursor", color: "muted" },
    ] },
    { spans: [
      { text: "  Minimap,         ", color: "teal" },
      { text: "// Overview navigator", color: "muted" },
    ] },
    { spans: [
      { text: "  useZoomPan,      ", color: "amber" },
      { text: "// d3-zoom hook", color: "muted" },
    ] },
    { spans: [
      { text: "  usePeakPicking,  ", color: "amber" },
      { text: "// Auto peak detection", color: "muted" },
    ] },
    { spans: [
      { text: "  useNormalization, ", color: "amber" },
      { text: "// Reactive processing", color: "muted" },
    ] },
    { spans: [
      { text: "} ", color: "white" },
      { text: "from ", color: "purple" },
      { text: "\"spectraview\"", color: "green" },
    ] },
  ]}
/>

The hooks handle state. `useZoomPan` wraps d3-zoom with memoized scale management. `usePeakPicking` runs prominence-based peak detection reactively whenever spectra change. `useNormalization` applies spectral transformations — baseline correction, normalization, smoothing, derivatives — returning new `Spectrum` objects without mutating the originals.

This design means you can build a custom viewer that has a minimap and tooltip but no toolbar, or a comparison view with two independent zoom states, or a processing dashboard that chains `useNormalization` with `useHistory` for undo/redo.

## Parsing Four Formats

Spectroscopists store data in JCAMP-DX, CSV, SPC, and JSON. SpectraView parses all four.

<TerminalBlock
  client:visible
  title="parsers.ts"
  lines={[
    { prompt: "", spans: [
      { text: "import ", color: "purple" },
      { text: "{ parseJcamp, parseCsv, parseJson, parseSpc } ", color: "teal" },
      { text: "from ", color: "purple" },
      { text: "\"spectraview\"", color: "green" },
    ] },
    { spans: [{ text: "" }] },
    { spans: [{ text: "// JCAMP-DX — the IUPAC standard (.dx, .jdx)", color: "muted" }] },
    { prompt: "", spans: [
      { text: "const spectra ", color: "white" },
      { text: "= ", color: "red" },
      { text: "parseJcamp", color: "amber" },
      { text: "(jcampString)", color: "white" },
    ] },
    { spans: [{ text: "" }] },
    { spans: [{ text: "// SPC — Thermo/Galactic binary format", color: "muted" }] },
    { prompt: "", spans: [
      { text: "const spectra ", color: "white" },
      { text: "= ", color: "red" },
      { text: "parseSpc", color: "amber" },
      { text: "(arrayBuffer)  ", color: "white" },
      { text: "// DataView byte parsing", color: "muted" },
    ] },
    { spans: [{ text: "" }] },
    { spans: [{ text: "// CSV — auto-detects delimiter (, \\t ;)", color: "muted" }] },
    { prompt: "", spans: [
      { text: "const spectrum ", color: "white" },
      { text: "= ", color: "red" },
      { text: "parseCsv", color: "amber" },
      { text: "(csvText)", color: "white" },
    ] },
  ]}
/>

The SPC parser is the most interesting. SPC is a binary format from the 1990s — little-endian, variable-length headers, two different Y-data encodings (16-bit integer or 32-bit float), optional per-sub-spectrum X arrays. The parser reads the format using `DataView` for byte-level access, handles both single and multi-spectrum files, and automatically maps Thermo's numeric type codes to human-readable unit labels.

## Processing in the Browser

SpectraView includes spectral processing utilities that run entirely client-side. No server round-trip. No Python dependency.

<TerminalBlock
  client:visible
  title="processing.ts"
  lines={[
    { prompt: "", spans: [
      { text: "import ", color: "purple" },
      { text: "{", color: "white" },
    ] },
    { spans: [
      { text: "  baselineRubberBand,  ", color: "teal" },
      { text: "// Convex hull baseline correction", color: "muted" },
    ] },
    { spans: [
      { text: "  normalizeMinMax,     ", color: "teal" },
      { text: "// Scale to [0, 1]", color: "muted" },
    ] },
    { spans: [
      { text: "  normalizeSNV,        ", color: "teal" },
      { text: "// Standard Normal Variate", color: "muted" },
    ] },
    { spans: [
      { text: "  smoothSavitzkyGolay, ", color: "teal" },
      { text: "// SG smoothing (windows 5-11)", color: "muted" },
    ] },
    { spans: [
      { text: "  derivative1st,       ", color: "teal" },
      { text: "// Central differences", color: "muted" },
    ] },
    { spans: [
      { text: "  differenceSpectrum,  ", color: "teal" },
      { text: "// A − B", color: "muted" },
    ] },
    { spans: [
      { text: "  correlationCoefficient, ", color: "teal" },
      { text: "// Pearson r", color: "muted" },
    ] },
    { spans: [
      { text: "} ", color: "white" },
      { text: "from ", color: "purple" },
      { text: "\"spectraview\"", color: "green" },
    ] },
    { spans: [{ text: "" }] },
    { spans: [{ text: "// All pure functions: Float64Array → Float64Array", color: "muted" }] },
    { prompt: "", spans: [
      { text: "const corrected ", color: "white" },
      { text: "= ", color: "red" },
      { text: "baselineRubberBand", color: "amber" },
      { text: "(spectrum.y)", color: "white" },
    ] },
    { prompt: "", spans: [
      { text: "const smoothed  ", color: "white" },
      { text: "= ", color: "red" },
      { text: "smoothSavitzkyGolay", color: "amber" },
      { text: "(corrected, 7)", color: "white" },
    ] },
    { prompt: "", spans: [
      { text: "const r         ", color: "white" },
      { text: "= ", color: "red" },
      { text: "correlationCoefficient", color: "amber" },
      { text: "(specA, specB)", color: "white" },
      { text: "  // → 0.97", color: "muted" },
    ] },
  ]}
/>

Every processing function follows the same contract as [SpectraKit](/blog/spectrakit): <span class="highlight-teal">arrays in, arrays out</span>. No mutation, no side effects. The `useNormalization` hook wraps these into a reactive pipeline — change the mode from "none" to "snv" and all spectra re-render with SNV normalization applied, memoized so it doesn't recompute on every frame.

## The SpectraKit Connection

SpectraView and [SpectraKit](/projects/spectrakit) are companion libraries that share the same design philosophy but target different runtimes:

<CodeComparison
  client:visible
  title="Two runtimes, one workflow"
  beforeTitle="SpectraKit (Python)"
  afterTitle="SpectraView (Browser)"
  before={[
    { text: "# Server-side preprocessing", type: "comment" },
    { text: "from spectrakit.baseline import baseline_als", type: "added" },
    { text: "from spectrakit.smooth import smooth_savgol", type: "added" },
    { text: "from spectrakit.normalize import normalize_snv", type: "added" },
    { text: "", type: "comment" },
    { text: "corrected = baseline_als(raw)", type: "added" },
    { text: "smoothed = smooth_savgol(corrected)", type: "added" },
    { text: "result = normalize_snv(smoothed)", type: "added" },
  ]}
  after={[
    { text: "// Client-side visualization", type: "comment" },
    { text: "import { baselineRubberBand } from 'spectraview'", type: "added" },
    { text: "import { smoothSavitzkyGolay } from 'spectraview'", type: "added" },
    { text: "import { normalizeSNV } from 'spectraview'", type: "added" },
    { text: "", type: "comment" },
    { text: "const corrected = baselineRubberBand(raw)", type: "added" },
    { text: "const smoothed = smoothSavitzkyGolay(corrected)", type: "added" },
    { text: "const result = normalizeSNV(smoothed)", type: "added" },
  ]}
/>

Process heavy datasets with SpectraKit in Python. Visualize results with SpectraView in the browser. Both use functional APIs over typed arrays. A spectrum processed by one library can be displayed by the other with zero transformation.

## Testing

<span class="highlight-teal">266 tests</span> across 35 test files. Every component, hook, parser, and utility function is tested. The test suite covers:

- **Parsers** — JCAMP-DX, CSV, JSON, SPC binary format parsing
- **Processing** — Baseline correction, normalization, smoothing, derivatives
- **Comparison** — Difference, correlation, interpolation
- **Components** — All 15 React components via Testing Library
- **Hooks** — Zoom/pan, peak detection, region selection, undo/redo

<TerminalBlock
  client:visible
  title="test_results.sh"
  lines={[
    { spans: [{ text: "$ npm run test:run", color: "muted" }] },
    { spans: [{ text: "" }], delay: 200 },
    { spans: [
      { text: " ✓ ", color: "green" },
      { text: "src/parsers/__tests__/spc.test.ts ", color: "white" },
      { text: "(10 tests)", color: "muted" },
    ] },
    { spans: [
      { text: " ✓ ", color: "green" },
      { text: "src/utils/__tests__/processing.test.ts ", color: "white" },
      { text: "(18 tests)", color: "muted" },
    ] },
    { spans: [
      { text: " ✓ ", color: "green" },
      { text: "src/utils/__tests__/comparison.test.ts ", color: "white" },
      { text: "(13 tests)", color: "muted" },
    ] },
    { spans: [
      { text: " ✓ ", color: "green" },
      { text: "src/hooks/__tests__/useHistory.test.ts ", color: "white" },
      { text: "(9 tests)", color: "muted" },
    ] },
    { spans: [
      { text: " ✓ ", color: "green" },
      { text: "... 31 more test files", color: "muted" },
    ] },
    { spans: [{ text: "" }] },
    { spans: [
      { text: " Test Files  ", color: "muted" },
      { text: "35 passed", color: "green" },
      { text: " (35)", color: "muted" },
    ] },
    { spans: [
      { text: "      Tests  ", color: "muted" },
      { text: "266 passed", color: "green" },
      { text: " (266)", color: "muted" },
    ] },
  ]}
/>

## What's Next

SpectraView is the visualization layer for [Spektron](/projects/spektron). The next integration is a prediction viewer — load a spectrum, run it through the Spektron model, and overlay the predicted molecular structure alongside the input spectrum. The composable architecture makes this straightforward: add a new component, wire it to the existing zoom state, render.

## Related

- **Storybook:** [Live demos](https://ktubhyam.github.io/spectraview/) — interactive component playground with 15 stories
- **Companion library:** [SpectraKit](/blog/spectrakit) — Python preprocessing with the same functional API philosophy
- **Foundation model:** [Spektron](/projects/spektron) — uses SpectraView as its visualization frontend
- **Architecture insight:** [Why Spectra Are Harder Than Images](/blog/why-spectra-are-harder-than-images) — the domain challenges that shaped SpectraView's design

<TerminalBlock
  client:visible
  title="spectraview — summary"
  lines={[
    { spans: [{ text: "$ npx spectraview --info", color: "muted" }] },
    { spans: [{ text: "" }], delay: 200 },
    { spans: [
      { text: "  version:    ", color: "muted" },
      { text: "1.8.1", color: "amber" },
    ] },
    { spans: [
      { text: "  install:    ", color: "muted" },
      { text: "npm install spectraview", color: "green" },
    ] },
    { spans: [
      { text: "  bundle:     ", color: "muted" },
      { text: "48KB ESM", color: "green" },
      { text: " + ", color: "muted" },
      { text: "51KB CJS", color: "green" },
    ] },
    { spans: [
      { text: "  tests:      ", color: "muted" },
      { text: "266 passed", color: "green" },
      { text: " across 35 files", color: "muted" },
    ] },
    { spans: [
      { text: "  typescript: ", color: "muted" },
      { text: "strict mode", color: "green" },
      { text: ", full type definitions", color: "muted" },
    ] },
    { spans: [
      { text: "  components: ", color: "muted" },
      { text: "15", color: "white" },
      { text: " (Canvas + SVG hybrid)", color: "muted" },
    ] },
    { spans: [
      { text: "  hooks:      ", color: "muted" },
      { text: "9", color: "white" },
      { text: " (zoom, peaks, normalization, history)", color: "muted" },
    ] },
    { spans: [
      { text: "  parsers:    ", color: "muted" },
      { text: "4", color: "white" },
      { text: " (JCAMP-DX, CSV, JSON, SPC)", color: "muted" },
    ] },
    { spans: [
      { text: "  react:      ", color: "muted" },
      { text: "18 + 19", color: "white" },
    ] },
    { spans: [
      { text: "  deps:       ", color: "muted" },
      { text: "d3-scale + d3-zoom", color: "teal" },
      { text: " (5 total)", color: "muted" },
    ] },
    { spans: [{ text: "" }] },
    { spans: [
      { text: "→ ", color: "muted" },
      { text: "github.com/ktubhyam/spectraview", color: "amber" },
    ] },
  ]}
/>
