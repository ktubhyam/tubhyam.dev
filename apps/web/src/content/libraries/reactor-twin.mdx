---
title: "ReactorTwin"
date: 2026-02-28
description: "Physics-constrained neural ODE surrogate for chemical reactor digital twins. Runs 1500x faster than CFD while enforcing mass balance, energy conservation, and thermodynamic consistency. v1.0.0, production stable."
language: "python"
github: "https://github.com/ktubhyam/reactor-twin"
docs: "https://ktubhyam.github.io/reactor-twin/"
status: "stable"
tags: ["python", "pytorch", "neural-odes", "chemical-engineering", "digital-twin"]
---

ReactorTwin builds fast surrogate models of chemical reactors using neural ODEs — 1500x faster than traditional first-principles simulation while enforcing physical conservation laws by design, not as a soft penalty.

## Install

```bash
pip install reactor-twin
```

## Quick Start

```python
from reactor_twin import NeuralODE
from reactor_twin.reactors.systems import create_exothermic_cstr
from reactor_twin.training import Trainer, ReactorDataGenerator
import torch, numpy as np

reactor = create_exothermic_cstr()
model = NeuralODE(state_dim=reactor.state_dim, solver="dopri5", adjoint=True)

gen = ReactorDataGenerator(reactor)
optimizer = torch.optim.Adam(model.parameters(), lr=1e-3)
trainer = Trainer(model=model, data_generator=gen, optimizer=optimizer)

t_span = (0.0, 10.0)
t_eval = np.linspace(0, 10, 50)
history = trainer.train(num_epochs=100, batch_size=32, t_span=t_span, t_eval=t_eval)

# Inference: 1500x faster than scipy.integrate
z0 = torch.tensor(reactor.get_initial_state()).unsqueeze(0)
traj = model.predict(z0, torch.tensor(t_eval))  # (1, T, state_dim)
```

## Core Capabilities

- **5 Neural DE variants** — NeuralODE, LatentNeuralODE, AugmentedNeuralODE, NeuralSDE, NeuralCDE; all with adjoint backprop via `torchdiffeq`
- **7 hard physics constraints** — projection-based (exact satisfaction, not soft penalty): mass balance, energy balance, thermodynamics, stoichiometry, port-Hamiltonian, GENERIC, positivity
- **8 reactor types** — CSTR, Batch, SemiBatch, PFR (Method of Lines), MultiPhase, Membrane, FluidizedBed, PopulationBalance
- **Digital twin stack** — EKF state estimation (autograd Jacobians), 4-level fault detection (EWMA+CUSUM+Mahalanobis+SVM/RF), MPC (LBFGS warm-start, economic, stochastic), online adaptation (EWC + replay buffer), Reptile meta-learning
- **ONNX export** — NeuralODE/Latent/Augmented → ONNX Runtime; inference benchmarks included
- **REST API** — FastAPI v1 (physics sim) + v2 (JWT auth, model upload/predict)
- **CLI** — `reactor-twin train | serve | export | dashboard`
- **Kubernetes** — Helm chart with HPA, Ingress, GPU Dockerfile

## Physics Constraints

ReactorTwin encodes constraints directly into the architecture via projection — not as loss penalties:

```python
from reactor_twin.physics import MassBalanceConstraint, PositivityConstraint, ConstraintPipeline
import torch

S = torch.tensor([[1, -1, 0], [0, 1, -1]], dtype=torch.float32)  # stoichiometry

pipeline = ConstraintPipeline([
    MassBalanceConstraint(stoichiometry=S, mode="hard"),  # exact projection
    PositivityConstraint(mode="hard"),                    # ReLU clamp
])
z_corrected = pipeline(z_predicted)
```

Hard mode: projection onto the constraint manifold — exact satisfaction by construction.
Soft mode: `constraint.violation(z)` returns a scalar penalty for the training loss.

## Digital Twin

```python
from reactor_twin import EKFStateEstimator, FaultDetector, MPCController

# State estimation fused with Neural ODE
ekf = EKFStateEstimator(model=neural_ode, obs_dim=2, process_noise=0.01, obs_noise=0.1)
z_hat, P = ekf.predict(z_prev, P_prev, dt=0.1)
z_hat, P = ekf.update(z_hat, P, observation=y_obs)

# Fault detection: EWMA + CUSUM + Mahalanobis + SVM
detector = FaultDetector(model=neural_ode, ewma_alpha=0.1, cusum_threshold=5.0)
detector.fit(normal_data)
status = detector.detect(new_obs)  # {"ewma_alarm": bool, "fault_type": str | None}

# Model predictive control (LBFGS, warm-started, <100ms per solve)
mpc = MPCController(model=neural_ode, horizon=20, dt=0.1, u_min=-1.0, u_max=1.0)
u_opt = mpc.solve(current_state, reference)
```

## Performance

| Task | scipy.integrate | ReactorTwin |
|------|----------------|-------------|
| CSTR steady-state | 45s | 0.03s |
| PFR concentration profile | 120s | 0.08s |
| Parameter sweep (100 conditions) | 4.5 hr | 3s |

Accuracy on held-out conditions: RMSE < 2% for concentration, < 1K for temperature.

## Related

- **Project:** [ReactorTwin](/projects/reactor-twin) — full architecture and training pipeline
- **Blog:** [Neural ODEs for Reactor Modeling](/blog/neural-odes-for-reactor-modeling)
- **Related:** [Spektron](/projects/spektron) — physics-informed deep learning for spectral data
