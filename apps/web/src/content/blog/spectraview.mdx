---
title: "SpectraView: Canvas-First Spectral Visualization for the Browser"
date: 2026-02-05
description: "Canvas for data, SVG for UI: how SpectraView renders 10K-point spectra at 60fps with composable hooks and snap-to-data crosshairs."
tags: ["typescript", "react", "spectroscopy", "open-source", "visualization"]
draft: false
---

import TerminalBlock from '@components/islands/TerminalBlock';
import CodeComparison from '@components/islands/CodeComparison';
import PipelineFlow from '@components/islands/PipelineFlow';
import FileTree from '@components/islands/FileTree';
import SpectrumViz from '@components/islands/SpectrumViz';
import MetricCards from '@components/islands/MetricCards';

Most spectrum viewers on the web use Plotly, Chart.js, or an SVG-based charting library. These work fine for 50-point bar charts. They do not work for vibrational spectra — 2,048 to 8,192 data points, sub-wavenumber precision, users who zoom in to inspect individual peak shoulders. The DOM chokes. Interactions lag. Scientists go back to Origin.

SpectraView exists because I needed a spectrum viewer for [Spektron](/projects/spektron) that could render IR and Raman spectra in the browser without compromise. It's a React component — <span class="highlight">npm install spectraview</span> — that renders spectral data on Canvas and everything else on SVG.

<SpectrumViz
  client:visible
  title="What SpectraView Renders"
  xLabel="Wavenumber (cm⁻¹)"
  yLabel="Absorbance"
  peaks={[
    { position: 0.10, height: 0.65, width: 0.035, color: "#4ECDC4", label: "O-H 3300" },
    { position: 0.22, height: 0.80, width: 0.018, color: "#C9A04A", label: "C-H 2900" },
    { position: 0.27, height: 0.55, width: 0.015, color: "#C9A04A" },
    { position: 0.45, height: 0.90, width: 0.02, color: "#FF6B6B", label: "C=O 1700" },
    { position: 0.55, height: 0.35, width: 0.018, color: "#A78BFA" },
    { position: 0.62, height: 0.50, width: 0.015, color: "#A78BFA" },
    { position: 0.75, height: 0.70, width: 0.025, color: "#60A5FA", label: "C-C 1000" },
    { position: 0.82, height: 0.45, width: 0.018, color: "#34D399" },
    { position: 0.90, height: 0.35, width: 0.015, color: "#34D399" },
  ]}
/>

<TerminalBlock
  client:visible
  title="install + use"
  lines={[
    { spans: [{ text: "$ npm install spectraview", color: "muted" }] },
    { spans: [{ text: "" }], delay: 200 },
    { spans: [
      { text: "added ", color: "muted" },
      { text: "spectraview@1.8.1", color: "green" },
      { text: " (5 deps, 48KB ESM)", color: "muted" },
    ] },
  ]}
/>

<MetricCards
  client:visible
  metrics={[
    {
      label: "Components",
      value: 15,
      color: "#60A5FA",
      sparkline: [0.3, 0.4, 0.5, 0.6, 0.7, 0.7, 0.8, 0.9, 1.0, 1.0],
      trend: "up",
    },
    {
      label: "Hooks",
      value: 9,
      color: "#4ECDC4",
      sparkline: [0.2, 0.3, 0.4, 0.5, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],
      trend: "up",
    },
    {
      label: "Tests",
      value: 266,
      color: "#34D399",
      sparkline: [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],
      trend: "up",
    },
    {
      label: "File Parsers",
      value: 4,
      color: "#C9A04A",
      sparkline: [0.5, 0.5, 0.5, 0.75, 0.75, 0.75, 1.0, 1.0, 1.0, 1.0],
      trend: "stable",
    },
    {
      label: "Render Speed",
      value: 60,
      suffix: "fps",
      color: "#A78BFA",
      sparkline: [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0],
      trend: "stable",
    },
  ]}
/>

## The Rendering Pipeline

Every frame follows the same path: raw data comes in, gets downsampled to the visible resolution, draws onto Canvas as a single polyline, then SVG handles the interactive overlay. This split is what makes 60fps possible at 10,000 points.

<PipelineFlow
  client:visible
  title="spectraview — rendering pipeline"
  stages={[
    { label: "Data", icon: "M4 7v10c0 2.21 3.582 4 8 4s8-1.79 8-4V7M4 7c0 2.21 3.582 4 8 4s8-1.79 8-4M4 7c0-2.21 3.582-4 8-4s8 1.79 8 4", color: "#60A5FA", detail: "10K+ raw points" },
    { label: "LTTB", icon: "M4 4v16h16 M7 14l4-6 4 4 4-8", color: "#4ECDC4", detail: "Downsample to ~500" },
    { label: "Canvas", icon: "M3 3h18v14H3z M7 12l3-4 3 3 4-5", color: "#C9A04A", detail: "Draw spectrum path" },
    { label: "SVG", icon: "M12 2L2 7l10 5 10-5-10-5z M2 17l10 5 10-5 M2 12l10 5 10-5", color: "#A78BFA", detail: "Crosshair, labels, grid" },
    { label: "Events", icon: "M15 15l5 5m-5-5v4m0-4h4 M4 4h7v7H4z M4 13h7v7H4z M13 4h7v7h-7z", color: "#34D399", detail: "Pan, zoom, snap-to-data" },
  ]}
/>

## The Rendering Split

A spectrum is a dense polyline — thousands of (x, y) pairs connected by segments. SVG represents each segment as a DOM node. At 4,000 points, that's 4,000 `<line>` or `<path>` elements that the browser must lay out, paint, and composite. Zooming reflows the entire subtree.

Canvas has none of this overhead. `ctx.lineTo()` draws to a pixel buffer. 10,000 points take the same time as 100. But Canvas has no event model, no hover detection, no accessible text.

SpectraView uses <span class="highlight-teal">both</span>. The spectral data renders on Canvas for performance. Axes, grid lines, peak markers, annotations, and the crosshair render as SVG for interactivity and accessibility. The layers are composited by absolute positioning within a single container.

<CodeComparison
  client:visible
  title="Rendering architecture"
  beforeTitle="SVG-only (typical)"
  afterTitle="Canvas + SVG (SpectraView)"
  before={[
    { text: "<!-- Every data point is a DOM node -->", type: "comment" },
    { text: "<svg width={800} height={400}>", type: "removed" },
    { text: "  <path d='M0,100 L1,102 L2,98 ...' />", type: "removed" },
    { text: "  <!-- 4000+ path segments -->", type: "comment" },
    { text: "  <circle cx={200} cy={50} />  <!-- peak -->", type: "removed" },
    { text: "  <line x1={0} x2={800} />     <!-- axis -->", type: "removed" },
    { text: "</svg>", type: "removed" },
  ]}
  after={[
    { text: "<!-- Canvas: pixel buffer, zero DOM nodes -->", type: "comment" },
    { text: "<canvas />  {/* 10K points at 60fps */}", type: "added" },
    { text: "", type: "comment" },
    { text: "<!-- SVG: only interactive elements -->", type: "comment" },
    { text: "<svg>  {/* axes + peaks + crosshair */}", type: "added" },
    { text: "  <g class='axis' />     {/* ~20 ticks */}", type: "added" },
    { text: "  <circle />             {/* peak marker */}", type: "added" },
    { text: "</svg>", type: "added" },
  ]}
/>

## Performance: Why the Split Matters

The difference between SVG-only and Canvas+SVG isn't academic. It's the difference between a usable tool and a frustrating one. Here are the actual numbers from benchmarking with a typical IR spectrum at various point counts:

<div class="callout callout-result">
  <div class="callout-label">SVG-only rendering at 10,000 points</div>

SVG creates 10,000 DOM elements — one `<line>` or path segment per data point. Browser tab memory spikes to **200MB**. Frame rate drops to **8fps** during pan operations. Zooming triggers a full reflow of the SVG subtree, which takes 120ms — visible as a stutter every time you scroll the mouse wheel. Opening DevTools shows the Recalculate Style phase dominating the frame budget. Panning feels like dragging through mud.

</div>

<div class="callout callout-result">
  <div class="callout-label">Canvas + SVG hybrid at 10,000 points</div>

Canvas draws the entire spectrum path as a single bitmap operation — `beginPath()`, a loop of `lineTo()` calls, one `stroke()`. Memory stays at **30MB**. Frame rate locks at **60fps** because the Canvas draw call takes less than 2ms, well within the 16ms frame budget. The SVG overlay handles only interactive elements — the crosshair, peak labels, axis ticks, and selection region — typically fewer than **50 DOM nodes** regardless of how many data points are in the spectrum.

</div>

The memory difference is the most dramatic. At 50,000 points (common for high-resolution Raman spectra), SVG-only rendering causes Chrome to allocate over 800MB for the tab. The Canvas hybrid stays under 40MB because the pixel buffer is fixed at the canvas resolution — 1600x800 pixels regardless of data density.

Zoom performance is where the architecture pays off most. When the user zooms into a region, SpectraView re-runs LTTB downsampling on the visible window, clears the canvas, and redraws. The entire operation takes 3-4ms. In SVG, the equivalent operation requires updating the `d` attribute of a `<path>` element with 10,000 new coordinate pairs, which triggers a full DOM parse and relayout.

## LTTB Downsampling

Even Canvas has limits. Drawing 50,000 `lineTo` calls per frame during a zoom animation is wasteful — most segments map to the same pixel column. SpectraView uses the <span class="highlight">Largest-Triangle-Three-Buckets</span> (LTTB) algorithm to reduce the rendered point count to `plotWidth * 2` while preserving visual fidelity.

LTTB divides the data into equal-sized buckets and selects the point in each bucket that forms the largest triangle with its neighbors. Unlike simple min-max decimation, it preserves the visual shape of peaks and shoulders. The downsampling happens per frame on the zoomed window, so you never lose resolution — zoom in and the algorithm selects more detail.

The implementation is adapted from Sveinn Steinarsson's original paper. A key optimization: SpectraView pre-sorts the data by x-coordinate and uses a sliding-window approach rather than re-partitioning the entire dataset on every zoom change. For a 50,000-point spectrum, LTTB downsampling to 1,000 display points takes 0.8ms — fast enough to run every frame during a smooth zoom animation.

## Composable Architecture

SpectraView is not a monolithic charting component. It's <span class="highlight-teal">15 components and 9 hooks</span> that compose together. The main `<SpectraView />` component is a convenience wrapper — every internal layer is independently exported.

<FileTree
  client:visible
  title="spectraview — component architecture"
  tree={[
    {
      name: "spectraview/", type: "folder", children: [
        {
          name: "src/", type: "folder", children: [
            {
              name: "components/", type: "folder", children: [
                { name: "SpectraView.tsx", type: "file" },
                { name: "SpectrumCanvas.tsx", type: "file" },
                { name: "AxisLayer.tsx", type: "file" },
                { name: "GridLines.tsx", type: "file" },
                { name: "PeakMarkers.tsx", type: "file" },
                { name: "Crosshair.tsx", type: "file" },
                { name: "Minimap.tsx", type: "file" },
                { name: "Toolbar.tsx", type: "file" },
                { name: "Tooltip.tsx", type: "file" },
                { name: "Legend.tsx", type: "file" },
                { name: "RegionSelector.tsx", type: "file" },
                { name: "OverlayManager.tsx", type: "file" },
                { name: "ExportButton.tsx", type: "file" },
                { name: "ThemeProvider.tsx", type: "file" },
                { name: "AccessibleTable.tsx", type: "file" },
              ],
            },
            {
              name: "hooks/", type: "folder", children: [
                { name: "useSpectrum.ts", type: "file" },
                { name: "useZoomPan.ts", type: "file" },
                { name: "usePeakPicking.ts", type: "file" },
                { name: "useNormalization.ts", type: "file" },
                { name: "useCrosshair.ts", type: "file" },
                { name: "useRegionSelect.ts", type: "file" },
                { name: "useHistory.ts", type: "file" },
                { name: "useExport.ts", type: "file" },
                { name: "useTheme.ts", type: "file" },
              ],
            },
            {
              name: "parsers/", type: "folder", children: [
                { name: "jcamp.ts", type: "file" },
                { name: "spc.ts", type: "file" },
                { name: "csv.ts", type: "file" },
                { name: "json.ts", type: "file" },
              ],
            },
            {
              name: "utils/", type: "folder", children: [
                { name: "lttb.ts", type: "file" },
                { name: "processing.ts", type: "file" },
                { name: "comparison.ts", type: "file" },
                { name: "scales.ts", type: "file" },
              ],
            },
          ],
        },
        { name: "package.json", type: "file" },
        { name: "tsconfig.json", type: "file" },
      ],
    },
  ]}
/>

<TerminalBlock
  client:visible
  title="composition.tsx"
  lines={[
    { spans: [{ text: "// Use the batteries-included component", color: "muted" }] },
    { prompt: "", spans: [
      { text: "import ", color: "purple" },
      { text: "{ SpectraView } ", color: "white" },
      { text: "from ", color: "purple" },
      { text: "\"spectraview\"", color: "green" },
    ] },
    { spans: [{ text: "" }] },
    { spans: [{ text: "// Or compose your own from primitives", color: "muted" }] },
    { prompt: "", spans: [
      { text: "import ", color: "purple" },
      { text: "{", color: "white" },
    ] },
    { spans: [
      { text: "  SpectrumCanvas,  ", color: "teal" },
      { text: "// Canvas data layer", color: "muted" },
    ] },
    { spans: [
      { text: "  AxisLayer,       ", color: "teal" },
      { text: "// SVG axes + grid", color: "muted" },
    ] },
    { spans: [
      { text: "  PeakMarkers,     ", color: "teal" },
      { text: "// SVG peak annotations", color: "muted" },
    ] },
    { spans: [
      { text: "  Crosshair,       ", color: "teal" },
      { text: "// Snap-to-data cursor", color: "muted" },
    ] },
    { spans: [
      { text: "  Minimap,         ", color: "teal" },
      { text: "// Overview navigator", color: "muted" },
    ] },
    { spans: [
      { text: "  useZoomPan,      ", color: "amber" },
      { text: "// d3-zoom hook", color: "muted" },
    ] },
    { spans: [
      { text: "  usePeakPicking,  ", color: "amber" },
      { text: "// Auto peak detection", color: "muted" },
    ] },
    { spans: [
      { text: "  useNormalization, ", color: "amber" },
      { text: "// Reactive processing", color: "muted" },
    ] },
    { spans: [
      { text: "} ", color: "white" },
      { text: "from ", color: "purple" },
      { text: "\"spectraview\"", color: "green" },
    ] },
  ]}
/>

The hooks handle state. `useZoomPan` wraps d3-zoom with memoized scale management. `usePeakPicking` runs prominence-based peak detection reactively whenever spectra change. `useNormalization` applies spectral transformations — baseline correction, normalization, smoothing, derivatives — returning new `Spectrum` objects without mutating the originals.

This design means you can build a custom viewer that has a minimap and tooltip but no toolbar, or a comparison view with two independent zoom states, or a processing dashboard that chains `useNormalization` with `useHistory` for undo/redo.

## Building a Custom Viewer in 4 Steps

The composable architecture means you can build exactly the viewer you need, nothing more. Here's a step-by-step walkthrough of building a custom spectral viewer with navigation overview and automatic peak annotation.

**Step 1: Load data with the `useSpectrum` hook.** This hook manages the spectrum data lifecycle — loading, parsing, and providing typed access to wavenumbers and intensities. It accepts raw arrays, file objects, or URL strings and normalizes them all into the same `Spectrum` type.

<TerminalBlock
  client:visible
  title="step1_data.tsx"
  lines={[
    { prompt: "", spans: [
      { text: "import ", color: "purple" },
      { text: "{ useSpectrum } ", color: "teal" },
      { text: "from ", color: "purple" },
      { text: "\"spectraview\"", color: "green" },
    ] },
    { spans: [{ text: "" }] },
    { prompt: "", spans: [
      { text: "function ", color: "purple" },
      { text: "MyViewer", color: "amber" },
      { text: "({ file }: { file: File }) {", color: "white" },
    ] },
    { spans: [
      { text: "  const { spectrum, loading, error } = ", color: "white" },
      { text: "useSpectrum", color: "amber" },
      { text: "(file)", color: "white" },
    ] },
    { spans: [{ text: "" }] },
    { spans: [
      { text: "  // spectrum.x: Float64Array (wavenumbers)", color: "muted" },
    ] },
    { spans: [
      { text: "  // spectrum.y: Float64Array (intensities)", color: "muted" },
    ] },
    { spans: [
      { text: "  // spectrum.meta: { title, origin, xUnits, yUnits }", color: "muted" },
    ] },
  ]}
/>

**Step 2: Add the Canvas layer for spectrum rendering.** `SpectrumCanvas` handles all the heavy lifting — LTTB downsampling, device-pixel-ratio scaling for Retina displays, and efficient redraw on zoom/pan.

<TerminalBlock
  client:visible
  title="step2_canvas.tsx"
  lines={[
    { prompt: "", spans: [
      { text: "import ", color: "purple" },
      { text: "{ SpectrumCanvas, useZoomPan } ", color: "teal" },
      { text: "from ", color: "purple" },
      { text: "\"spectraview\"", color: "green" },
    ] },
    { spans: [{ text: "" }] },
    { spans: [
      { text: "  const zoom = ", color: "white" },
      { text: "useZoomPan", color: "amber" },
      { text: "({ xDomain: spectrum.xRange, yDomain: spectrum.yRange })", color: "white" },
    ] },
    { spans: [{ text: "" }] },
    { spans: [
      { text: "  return (", color: "white" },
    ] },
    { spans: [
      { text: "    <SpectrumCanvas", color: "teal" },
    ] },
    { spans: [
      { text: "      spectrum={spectrum}", color: "white" },
    ] },
    { spans: [
      { text: "      zoom={zoom}", color: "white" },
    ] },
    { spans: [
      { text: "      color=\"#C9A04A\"", color: "white" },
    ] },
    { spans: [
      { text: "      lineWidth={1.5}", color: "white" },
    ] },
    { spans: [
      { text: "    />", color: "teal" },
    ] },
    { spans: [
      { text: "  )", color: "white" },
    ] },
  ]}
/>

**Step 3: Layer the Minimap for navigation.** The Minimap shows the full spectrum in miniature with a viewport indicator showing the currently zoomed region. Dragging the viewport pans the main view. The minimap renders on its own Canvas instance, so it doesn't interfere with the main view's frame budget.

<TerminalBlock
  client:visible
  title="step3_minimap.tsx"
  lines={[
    { prompt: "", spans: [
      { text: "import ", color: "purple" },
      { text: "{ Minimap } ", color: "teal" },
      { text: "from ", color: "purple" },
      { text: "\"spectraview\"", color: "green" },
    ] },
    { spans: [{ text: "" }] },
    { spans: [
      { text: "  <Minimap", color: "teal" },
    ] },
    { spans: [
      { text: "    spectrum={spectrum}", color: "white" },
    ] },
    { spans: [
      { text: "    zoom={zoom}", color: "white" },
    ] },
    { spans: [
      { text: "    height={60}", color: "white" },
    ] },
    { spans: [
      { text: "    color=\"#4ECDC440\"", color: "white" },
    ] },
    { spans: [
      { text: "  />", color: "teal" },
    ] },
  ]}
/>

**Step 4: Add automatic peak annotation with PeakMarkers.** The `usePeakPicking` hook runs prominence-based detection (using the same algorithm as SciPy's `find_peaks`) whenever the spectrum or zoom level changes. `PeakMarkers` renders the results as SVG circles with tooltips showing wavenumber and intensity values.

<TerminalBlock
  client:visible
  title="step4_peaks.tsx"
  lines={[
    { prompt: "", spans: [
      { text: "import ", color: "purple" },
      { text: "{ PeakMarkers, usePeakPicking } ", color: "teal" },
      { text: "from ", color: "purple" },
      { text: "\"spectraview\"", color: "green" },
    ] },
    { spans: [{ text: "" }] },
    { spans: [
      { text: "  const peaks = ", color: "white" },
      { text: "usePeakPicking", color: "amber" },
      { text: "(spectrum, {", color: "white" },
    ] },
    { spans: [
      { text: "    prominence: 0.05,  ", color: "white" },
      { text: "// minimum peak prominence", color: "muted" },
    ] },
    { spans: [
      { text: "    distance: 20,      ", color: "white" },
      { text: "// minimum distance between peaks (points)", color: "muted" },
    ] },
    { spans: [
      { text: "  })", color: "white" },
    ] },
    { spans: [{ text: "" }] },
    { spans: [
      { text: "  <PeakMarkers peaks={peaks} zoom={zoom} color=\"#FF6B6B\" />", color: "teal" },
    ] },
  ]}
/>

Each step adds exactly one capability. No step requires any other (except `useZoomPan`, which all layers share for coordinate synchronization). You can stop at step 2 for a minimal viewer, or continue adding `Crosshair`, `Toolbar`, `RegionSelector`, and `Legend` as needed.

## Parsing Four Formats

Spectroscopists store data in JCAMP-DX, CSV, SPC, and JSON. SpectraView parses all four.

<TerminalBlock
  client:visible
  title="parsers.ts"
  lines={[
    { prompt: "", spans: [
      { text: "import ", color: "purple" },
      { text: "{ parseJcamp, parseCsv, parseJson, parseSpc } ", color: "teal" },
      { text: "from ", color: "purple" },
      { text: "\"spectraview\"", color: "green" },
    ] },
    { spans: [{ text: "" }] },
    { spans: [{ text: "// JCAMP-DX — the IUPAC standard (.dx, .jdx)", color: "muted" }] },
    { prompt: "", spans: [
      { text: "const spectra ", color: "white" },
      { text: "= ", color: "red" },
      { text: "parseJcamp", color: "amber" },
      { text: "(jcampString)", color: "white" },
    ] },
    { spans: [{ text: "" }] },
    { spans: [{ text: "// SPC — Thermo/Galactic binary format", color: "muted" }] },
    { prompt: "", spans: [
      { text: "const spectra ", color: "white" },
      { text: "= ", color: "red" },
      { text: "parseSpc", color: "amber" },
      { text: "(arrayBuffer)  ", color: "white" },
      { text: "// DataView byte parsing", color: "muted" },
    ] },
    { spans: [{ text: "" }] },
    { spans: [{ text: "// CSV — auto-detects delimiter (, \\t ;)", color: "muted" }] },
    { prompt: "", spans: [
      { text: "const spectrum ", color: "white" },
      { text: "= ", color: "red" },
      { text: "parseCsv", color: "amber" },
      { text: "(csvText)", color: "white" },
    ] },
  ]}
/>

### JCAMP-DX: Six Formats in a Trenchcoat

JCAMP-DX is the IUPAC "standard" for spectral data exchange. In theory, it's a simple text format with labeled data records. In practice, it's six different encoding schemes wearing a trenchcoat pretending to be one format.

The two most common variants are `XYDATA` and `PEAK TABLE`. An `XYDATA` block contains the full spectrum — every data point — while a `PEAK TABLE` contains only peak positions and intensities. SpectraView's parser handles both, but `XYDATA` is where the complexity lives.

Within `XYDATA`, there's **AFFN** (ASCII Free Format Numeric) where each line contains explicit X,Y pairs, and **DIFDUP** where only the first X value is given along with a `##DELTAX` step size, and Y values are stored as differences from the previous value using a compressed single-character encoding. The compression scheme uses uppercase letters A-I to represent digits 1-9 for positive differences and lowercase a-i for negative differences, with `@` for zero. A single JCAMP file can contain multiple data blocks with different encoding schemes.

SpectraView's parser detects the encoding from the `##XYDATA=` line, handles DIFDUP decompression including the affine transform (`Y_real = Y_compressed * YFACTOR + YOFFSET`), and validates that the reconstructed X values match the declared `##FIRSTX` and `##LASTX` bounds within floating-point tolerance.

### SPC: Reverse-Engineering a Binary Format

The SPC parser is the most interesting. SPC is a binary format from the 1990s — little-endian, variable-length headers, two different Y-data encodings (16-bit integer or 32-bit float), optional per-sub-spectrum X arrays. The parser reads the format using `DataView` for byte-level access, handles both single and multi-spectrum files, and automatically maps Thermo's numeric type codes to human-readable unit labels.

The file structure starts with a 512-byte main header containing magic bytes, version flags, the number of sub-spectra, and type codes for X and Y units. The type codes are a numeric enum — 1 means wavenumber (cm-1), 2 means micrometers, 3 means nanometers, 13 means Raman shift, and so on up to type 27. After the header, sub-spectra are stored sequentially, each with its own 32-byte sub-header followed by Y data.

The trickiest part: Y-data encoding depends on the `ftflgs` byte in the main header. If bit 0 is set, Y values are 16-bit integers that need to be multiplied by an exponent stored in the header (`YREAL = Y_INT * 2^EXPONENT`). If bit 0 is clear, Y values are IEEE 754 32-bit floats. Older Galactic instruments always use the integer format. Newer Thermo instruments default to float. SpectraView detects both and converts to Float64Array for uniform downstream handling.

### CSV: The Non-Standard Standard

CSV is the format scientists default to when nothing else works. The problem: there is no standard. SpectraView's CSV parser handles three levels of ambiguity:

**Delimiter detection.** Is it comma-separated, tab-separated, or semicolon-separated? The parser scans the first 10 lines and counts occurrences of each candidate delimiter, choosing the one that produces the most consistent column count. European CSV files use semicolons because the comma is the decimal separator in those locales.

**Header detection.** Does the first row contain column names or data? The parser checks whether the first row contains any non-numeric values. If it does, it's treated as a header row and the column names are used for metadata. If all values are numeric, the first row is data.

**Wavenumber identification.** Which column is the X axis? The parser uses a heuristic: the first column with monotonically increasing or decreasing values and a range typical of spectroscopic data (400-4000 for IR, 100-4000 for Raman, 200-800 for UV-Vis) is treated as wavenumbers. All other numeric columns become Y series. This heuristic gets it right about 95% of the time — the remaining 5% is what the explicit column mapping API is for.

## Processing in the Browser

SpectraView includes spectral processing utilities that run entirely client-side. No server round-trip. No Python dependency.

<TerminalBlock
  client:visible
  title="processing.ts"
  lines={[
    { prompt: "", spans: [
      { text: "import ", color: "purple" },
      { text: "{", color: "white" },
    ] },
    { spans: [
      { text: "  baselineRubberBand,  ", color: "teal" },
      { text: "// Convex hull baseline correction", color: "muted" },
    ] },
    { spans: [
      { text: "  normalizeMinMax,     ", color: "teal" },
      { text: "// Scale to [0, 1]", color: "muted" },
    ] },
    { spans: [
      { text: "  normalizeSNV,        ", color: "teal" },
      { text: "// Standard Normal Variate", color: "muted" },
    ] },
    { spans: [
      { text: "  smoothSavitzkyGolay, ", color: "teal" },
      { text: "// SG smoothing (windows 5-11)", color: "muted" },
    ] },
    { spans: [
      { text: "  derivative1st,       ", color: "teal" },
      { text: "// Central differences", color: "muted" },
    ] },
    { spans: [
      { text: "  differenceSpectrum,  ", color: "teal" },
      { text: "// A − B", color: "muted" },
    ] },
    { spans: [
      { text: "  correlationCoefficient, ", color: "teal" },
      { text: "// Pearson r", color: "muted" },
    ] },
    { spans: [
      { text: "} ", color: "white" },
      { text: "from ", color: "purple" },
      { text: "\"spectraview\"", color: "green" },
    ] },
    { spans: [{ text: "" }] },
    { spans: [{ text: "// All pure functions: Float64Array → Float64Array", color: "muted" }] },
    { prompt: "", spans: [
      { text: "const corrected ", color: "white" },
      { text: "= ", color: "red" },
      { text: "baselineRubberBand", color: "amber" },
      { text: "(spectrum.y)", color: "white" },
    ] },
    { prompt: "", spans: [
      { text: "const smoothed  ", color: "white" },
      { text: "= ", color: "red" },
      { text: "smoothSavitzkyGolay", color: "amber" },
      { text: "(corrected, 7)", color: "white" },
    ] },
    { prompt: "", spans: [
      { text: "const r         ", color: "white" },
      { text: "= ", color: "red" },
      { text: "correlationCoefficient", color: "amber" },
      { text: "(specA, specB)", color: "white" },
      { text: "  // → 0.97", color: "muted" },
    ] },
  ]}
/>

Every processing function follows the same contract as [SpectraKit](/blog/spectrakit): <span class="highlight-teal">arrays in, arrays out</span>. No mutation, no side effects. The `useNormalization` hook wraps these into a reactive pipeline — change the mode from "none" to "snv" and all spectra re-render with SNV normalization applied, memoized so it doesn't recompute on every frame.

## The SpectraKit Connection

SpectraView and [SpectraKit](/projects/spectrakit) are companion libraries that share the same design philosophy but target different runtimes:

<CodeComparison
  client:visible
  title="Two runtimes, one workflow"
  beforeTitle="SpectraKit (Python)"
  afterTitle="SpectraView (Browser)"
  before={[
    { text: "# Server-side preprocessing", type: "comment" },
    { text: "from spectrakit.baseline import baseline_als", type: "added" },
    { text: "from spectrakit.smooth import smooth_savgol", type: "added" },
    { text: "from spectrakit.normalize import normalize_snv", type: "added" },
    { text: "", type: "comment" },
    { text: "corrected = baseline_als(raw)", type: "added" },
    { text: "smoothed = smooth_savgol(corrected)", type: "added" },
    { text: "result = normalize_snv(smoothed)", type: "added" },
  ]}
  after={[
    { text: "// Client-side visualization", type: "comment" },
    { text: "import { baselineRubberBand } from 'spectraview'", type: "added" },
    { text: "import { smoothSavitzkyGolay } from 'spectraview'", type: "added" },
    { text: "import { normalizeSNV } from 'spectraview'", type: "added" },
    { text: "", type: "comment" },
    { text: "const corrected = baselineRubberBand(raw)", type: "added" },
    { text: "const smoothed = smoothSavitzkyGolay(corrected)", type: "added" },
    { text: "const result = normalizeSNV(smoothed)", type: "added" },
  ]}
/>

Process heavy datasets with SpectraKit in Python. Visualize results with SpectraView in the browser. Both use functional APIs over typed arrays. A spectrum processed by one library can be displayed by the other with zero transformation.

The practical workflow looks like this: you preprocess 10,000 spectra using SpectraKit in a Python pipeline, export the results as HDF5 or JSON, and load them into a SpectraView-powered web dashboard for interactive exploration. The browser handles panning, zooming, peak picking, and comparison — the things scientists need to do interactively. The heavy preprocessing stays on the server where NumPy and SciPy run natively.

## Testing

<span class="highlight-teal">266 tests</span> across 35 test files. Every component, hook, parser, and utility function is tested. The test suite covers:

- **Parsers** — JCAMP-DX (including DIFDUP decompression), CSV (delimiter detection, header detection), JSON, SPC binary format (both integer and float Y-data)
- **Processing** — Baseline correction, normalization, smoothing, derivatives, with edge cases for empty arrays and constant signals
- **Comparison** — Difference spectrum, correlation coefficient, spectral angle, interpolation for mismatched X grids
- **Components** — All 15 React components via Testing Library, including Canvas mock rendering
- **Hooks** — Zoom/pan state management, peak detection accuracy, region selection, undo/redo stack integrity

<TerminalBlock
  client:visible
  title="test_results.sh"
  lines={[
    { spans: [{ text: "$ npm run test:run", color: "muted" }] },
    { spans: [{ text: "" }], delay: 200 },
    { spans: [
      { text: " ✓ ", color: "green" },
      { text: "src/parsers/__tests__/spc.test.ts ", color: "white" },
      { text: "(10 tests)", color: "muted" },
    ] },
    { spans: [
      { text: " ✓ ", color: "green" },
      { text: "src/parsers/__tests__/jcamp.test.ts ", color: "white" },
      { text: "(14 tests)", color: "muted" },
    ] },
    { spans: [
      { text: " ✓ ", color: "green" },
      { text: "src/utils/__tests__/processing.test.ts ", color: "white" },
      { text: "(18 tests)", color: "muted" },
    ] },
    { spans: [
      { text: " ✓ ", color: "green" },
      { text: "src/utils/__tests__/comparison.test.ts ", color: "white" },
      { text: "(13 tests)", color: "muted" },
    ] },
    { spans: [
      { text: " ✓ ", color: "green" },
      { text: "src/hooks/__tests__/useHistory.test.ts ", color: "white" },
      { text: "(9 tests)", color: "muted" },
    ] },
    { spans: [
      { text: " ✓ ", color: "green" },
      { text: "... 30 more test files", color: "muted" },
    ] },
    { spans: [{ text: "" }] },
    { spans: [
      { text: " Test Files  ", color: "muted" },
      { text: "35 passed", color: "green" },
      { text: " (35)", color: "muted" },
    ] },
    { spans: [
      { text: "      Tests  ", color: "muted" },
      { text: "266 passed", color: "green" },
      { text: " (266)", color: "muted" },
    ] },
  ]}
/>

The Canvas testing deserves mention. Testing Canvas rendering is notoriously difficult because the output is a pixel buffer, not a DOM tree. SpectraView's test suite uses a Canvas mock that records all draw calls — `beginPath`, `moveTo`, `lineTo`, `stroke` — as a call log. Tests assert on the sequence and coordinates of draw calls rather than pixel values. This catches regressions in the drawing logic (wrong scale transform, off-by-one in LTTB output) without the fragility of snapshot-based visual regression tests.

## What's Next

SpectraView is the visualization layer for [Spektron](/projects/spektron). The next integration is a prediction viewer — load a spectrum, run it through the Spektron model, and overlay the predicted molecular structure alongside the input spectrum. The composable architecture makes this straightforward: add a new component, wire it to the existing zoom state, render.

## Related

- **Storybook:** [Live demos](https://ktubhyam.github.io/spectraview/) — interactive component playground with 15 stories
- **Companion library:** [SpectraKit](/blog/spectrakit) — Python preprocessing with the same functional API philosophy
- **Foundation model:** [Spektron](/projects/spektron) — uses SpectraView as its visualization frontend
- **Architecture insight:** [Why Spectra Are Harder Than Images](/blog/why-spectra-are-harder-than-images) — the domain challenges that shaped SpectraView's design

<TerminalBlock
  client:visible
  title="spectraview — summary"
  lines={[
    { spans: [{ text: "$ npx spectraview --info", color: "muted" }] },
    { spans: [{ text: "" }], delay: 200 },
    { spans: [
      { text: "  version:    ", color: "muted" },
      { text: "1.8.1", color: "amber" },
    ] },
    { spans: [
      { text: "  install:    ", color: "muted" },
      { text: "npm install spectraview", color: "green" },
    ] },
    { spans: [
      { text: "  bundle:     ", color: "muted" },
      { text: "48KB ESM", color: "green" },
      { text: " + ", color: "muted" },
      { text: "51KB CJS", color: "green" },
    ] },
    { spans: [
      { text: "  tests:      ", color: "muted" },
      { text: "266 passed", color: "green" },
      { text: " across 35 files", color: "muted" },
    ] },
    { spans: [
      { text: "  typescript: ", color: "muted" },
      { text: "strict mode", color: "green" },
      { text: ", full type definitions", color: "muted" },
    ] },
    { spans: [
      { text: "  components: ", color: "muted" },
      { text: "15", color: "white" },
      { text: " (Canvas + SVG hybrid)", color: "muted" },
    ] },
    { spans: [
      { text: "  hooks:      ", color: "muted" },
      { text: "9", color: "white" },
      { text: " (zoom, peaks, normalization, history)", color: "muted" },
    ] },
    { spans: [
      { text: "  parsers:    ", color: "muted" },
      { text: "4", color: "white" },
      { text: " (JCAMP-DX, CSV, JSON, SPC)", color: "muted" },
    ] },
    { spans: [
      { text: "  react:      ", color: "muted" },
      { text: "18 + 19", color: "white" },
    ] },
    { spans: [
      { text: "  deps:       ", color: "muted" },
      { text: "d3-scale + d3-zoom", color: "teal" },
      { text: " (5 total)", color: "muted" },
    ] },
    { spans: [{ text: "" }] },
    { spans: [
      { text: "→ ", color: "muted" },
      { text: "github.com/ktubhyam/spectraview", color: "amber" },
    ] },
  ]}
/>
